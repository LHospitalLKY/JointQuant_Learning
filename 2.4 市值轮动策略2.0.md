# 市值轮动策略2.0
本部分主要介绍**自定义函数**、**共享函数库**、**均衡分配资金**等内容，相比之前的市值轮动策略，更
加复杂，也更加模块化。

## 自定义函数
在简单市值轮动中，只写了20多行的代码。但是当策略逐渐完善时，代码量逐渐变多。为了使代码有着更好的可
读性和复用性，需要通过定义函数的方法来使代码更有层次。

在前面的简单市值轮动中，我们可以把选股和交易分别抽出来单独定义为两个函数：

选股函数
```python
def pick(context):
	date=context.current_dt.strftime("%Y-%m-%d")
    # 获取上证指数和深证综指的成分股代码并连接，即为全A股市场所有股票
    scu = get_index_stocks('000001.XSHG')+get_index_stocks('399106.XSHE')

    # 选出在scu内的股票的股票代码，并按照当前时间市盈率从小到大排序
    df = get_fundamentals(query(
            valuation.code,valuation.pe_ratio
        ).filter(
            valuation.code.in_(scu),
            valuation.pe_ratio > 0
        ).order_by(
            valuation.pe_ratio.asc()
        ), date=date
        )
    print(df)
    # 取出前g.stocksnum名的股票代码，并转成list类型，buylist为选中的股票
    buylist =list(df['code'][:g.stocksnum])
	
	# 返回
	return buylist
```

交易函数
```python
def trade(context,buylist):
    for stock in context.portfolio.positions:
        if stock not in buylist:
            order_target(stock, 0)
    position_per_stk = context.portfolio.cash/g.stocksnum
    for stock in buylist:
        order_value(stock, position_per_stk)

    return 'Done!'
```

如此一来，daily函数九十分简洁，而且很容易就看清楚每日循环的逻辑：
```python
def daily(context):
	# 判断策略进行天数是否能被轮动频率整除余1
	if g.days % g.period == 1:
		# 选出要交易的股票
		buylist = pick(context)
		# 交易下单
		trade(context, buylist)
	else:
		pass
```


## 过滤停牌、涨停和st股
股票在某些情况下是无法交易的，例如出现涨停或者停牌的情况，我们要将这部分股票过滤。另外，st股



























